<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Engineering | Xutianming Blog]]></title>
  <link href="http://xutianming.github.io/blog/categories/engineering/atom.xml" rel="self"/>
  <link href="http://xutianming.github.io/"/>
  <updated>2016-08-31T23:02:44+08:00</updated>
  <id>http://xutianming.github.io/</id>
  <author>
    <name><![CDATA[Xutianming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Multiprocessing]]></title>
    <link href="http://xutianming.github.io/blog/2016/08/31/python-multiprocessing/"/>
    <updated>2016-08-31T21:21:00+08:00</updated>
    <id>http://xutianming.github.io/blog/2016/08/31/python-multiprocessing</id>
    <content type="html"><![CDATA[<p>It has been a long time since I updated my last blog. I decided to continue to write blogs to summarize my technical work.</p>

<p>In the last six months, Python has been my main programming language. I implemented a crawler and several web-based applications. I tried many excellent Python frameworks such as Django, Bottle, Scrapy. I will write several blogs to summarize the knowledge I got in my work.</p>

<p>The topic of today is multi-processing.</p>

<h3>Process vs Thread</h3>

<p>Normally we prefer thread to process because in most systems threads are cheaper than processes.  And threads share the same virtual memory space which they have independent calling stack. But because of global interpreter lock, only one thread can execute in a particular time. To side-step this drawback and utilize the advantage of multi-cores, I prefer processes to threads in Python.</p>

<h3>Multiprocessing Pool</h3>

<p>In the multiprocessing module of python, process pool is a very simple way to distribute work to many workers, so it became my first choice in the very beginning. But I met many problems while using it.</p>

<h4>memory leak</h4>

<p>As described in the <a href="http://stackoverflow.com/questions/21485319/high-memory-usage-using-python-multiprocessing/21613370"><em>post1</em></a> <a href="http://stackoverflow.com/questions/8777324/leaking-memory-with-multiprocessing-pool-even-after-close"><em>post2</em></a>, the memory usage will increase after a while. So for a server side application which runs for a long time, multiprocessing pool is not a good choice.</p>

<h4>pickling error</h4>

<p>As described in the <a href="http://stackoverflow.com/questions/8804830/python-multiprocessing-pickling-error?rq=1"><em>post</em></a>, I had to use a global wrapper for the method to be invoked in pool which made my code kind of ugly.</p>

<p>Using multiprocess pool, you lose a lot of control over your working processes which is not so convenient for complicated tasks. With all these drawbacks, I switched to Process class. I implemented a 2-level producer-consumer pattern which worked quite well.</p>

<h3>Producer-consumer</h3>

<p>In this <a href="https://pymotw.com/2/multiprocessing/communication.html"><em>article</em></a>, there is a good example of producer-consumer pattern which uses JoinableQueue and Poison Pill trick.</p>

<h4>JoinableQueue vs Queue</h4>

<p>JoinableQueue is a subclass of Queue and it adds task_done() and join() methods. <a href="http://stackoverflow.com/questions/31230241/queue-vs-joinablequeue-in-python"><em>ref</em></a></p>
]]></content>
  </entry>
  
</feed>
