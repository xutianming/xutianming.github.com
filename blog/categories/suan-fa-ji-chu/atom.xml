<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法基础 | Xutianming Blog]]></title>
  <link href="http://xutianming.github.io/blog/categories/suan-fa-ji-chu/atom.xml" rel="self"/>
  <link href="http://xutianming.github.io/"/>
  <updated>2013-08-26T14:37:54+08:00</updated>
  <id>http://xutianming.github.io/</id>
  <author>
    <name><![CDATA[Xutianming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ACM中递归问题解决方法思考]]></title>
    <link href="http://xutianming.github.io/blog/2013/08/20/recursion-problem-and-hmm-model/"/>
    <updated>2013-08-20T21:47:00+08:00</updated>
    <id>http://xutianming.github.io/blog/2013/08/20/recursion-problem-and-hmm-model</id>
    <content type="html"><![CDATA[<p>最近在做ACM的练习题来练习编程的基本功，今天研究到了递归问题。就是通过寻找递推公式，来解决问题。</p>

<p>在总结方法的过程中，发现，对于一些比较简单的题目，可以在纸上比较轻易的模拟过程的问题，可以通过观察第n项与前面的1-3项之间的关系，直接得到递推公式。</p>

<p>比如：</p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1001&amp;ojid=0&amp;cid=1531&amp;hide=0">超级楼梯</a></p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1002&amp;ojid=0&amp;cid=1531&amp;hide=0">一只小蜜蜂&hellip;</a></p>

<p>这些问题都比较简单直观，所以很容易思考直接获得递推公式。</p>

<p>而其他的一些问题，可能就相对来说抽象一些，需要我们画图，找一下规律，这时候千万不要怕麻烦，画图可以很直观的帮助我们找到规律，也就是递推公式。</p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1004&amp;ojid=0&amp;cid=1531&amp;hide=0">骨牌铺方格</a></p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1009&amp;ojid=0&amp;cid=1531&amp;hide=0">Tiling_easy version</a></p>

<p>比如上面这种铺砖的，画图之后，有目的的去观察，有n-1和n-2项如何去铺砖得第n项，就可以发现递推公式。这种一般从第三项之后，才会有规律。也就是找第四项和第三、第二项之间的关系。</p>

<p>总而言之，这类问题考验思维能力要强于对编程能力的考验。思考的方法更为重要。我大体总结了一下，这类问题主要有两种思考的方式，一种是从前往后，一种是从后往前。</p>

<p>从前往后，就是考察第一、第二项，这一般是递推公式的初始项，然后考察第三项、第四项、第五项，在计算这几项的时候，看能否提出一种可以推广的计算方法，这种方法，抽象来，就是递推公式。这种方法的优点是，比较直观，可以画图，容易理解，缺点是，有些问题没法解决。</p>

<p>从后往前，就是直接考察第n项的得出，有几种可能来构造第n项，每种可能如何用第n-1项、第n-2项的值，来构造。这种方法的优点是通用性更高一些，只要脑筋转的过来，大部分问题都可以通过这种方法找出递推公式。缺点就是比较抽象，不怎么好想。</p>

<p>写到这里，我觉得这种问题的解决，好像是HMM中的前向算法和后向算法，分别就是从前向后和从后向前，进行状态的转移。不过再仔细思考，这也只是形似而已，似乎在本质上，双方没有数学层面上的必然联系。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++输入输出总结]]></title>
    <link href="http://xutianming.github.io/blog/2013/08/07/c-plus-plus-input-and-output/"/>
    <updated>2013-08-07T09:23:00+08:00</updated>
    <id>http://xutianming.github.io/blog/2013/08/07/c-plus-plus-input-and-output</id>
    <content type="html"><![CDATA[<p>输入：
1 . 未说明有多少个input block</p>

<pre><code>while(scanf("%d %d",&amp;a,&amp;b)!=EOF) 
{    ...    }
</code></pre>

<p>scanf返回的是输入的变量的个数，EOF=-1表示没有输入</p>

<pre><code>while(cin&gt;&gt;a&gt;&gt;b) {    ...    }2 . 说明有N个input block    

scanf("%d",&amp;n) ;    for( i=0 ; i&lt;n ; i++ )     {...} 
    cin &gt;&gt; n;   for( i=0 ; i&lt;n ; i++ )     { .... } 3 . 输入是一整行的字符串
C  
char buf[20];     gets(buf); 

// 如果用string buf;来保存：
getline( cin , buf );     // 如果用char buf[ 255 ]; 来保存：     cin.getline( buf, 255 );
</code></pre>

<p><code>scanf(“ %s%s”,str1,str2)</code>，在多个字符串之间用一个或多个空格分隔；若使用gets函数，应为gets(str1); gets(str2); 字符串之间用回车符作分隔。通常情况下，接受短字符用scanf函数，接受长字符用gets函数。而getchar函数每次只接受一个字符，经常c=getchar()这样来使用。getline 是一个函数，它可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下：    <code>istream&amp; getline(char line[], int size, char endchar = '\n');</code>不用管它的返回类型，来关心它的三个参数：
* char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。<em> int size : 最多接受几个字符？用户超过size的输入都将不被接受。</em> char endchar :当用户输入endchar指定的字符时，自动结束。默认是回车符。例如：char name[4];cin.getline(name,4,&lsquo;\n&rsquo;);由于 endchar 默认已经是 &lsquo;\n'，所以后面那行也可以写成：cin.getline(name,4);输出：
1 . 输出之后换行    C:    {     &hellip;.     printf(&ldquo;%d\n&rdquo;,ans);     }     C++:    {     &hellip;     cout &lt;&lt; ans &lt;&lt; endl;     }
2 . 每个输出之间有空行</p>

<pre><code>  while(scanf("%d %d",&amp;a, &amp;b) != EOF)           printf("%d\n\n",a+b);    
C++:    cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p>3 . 输出结束之后输出空行</p>

<pre><code>C:    for (k=0;k&lt;count;k++) {     while (…) {              printf(" %d\n",result);       
  }       
  if (k!=count-1) printf("\n");     
}     C++   // 类似，输出语句换一下即可。
</code></pre>

<p>在学习了以上基础之后，我在HDUOJ上做了十几个题目来练习，也犯了不少错误，总结如下，以避免以后再犯，提高编程的成功率和效率：
* 未说明有多少个输入块时，scanf要和EOF比较，这个和cin的使用不同，不然的话OJ上会超时
* 同样的道理，也不要用<code>while(true)</code>来代替<code>while(cin&gt;&gt;a)</code>，也会在输入结束的时候，仍然执行从而超时
* 再就是输出有换行，要输出两个<code>endl</code>的时候，要注意假如指定输入个数，最后一次输出之后，不要再换行的。没指定有多少个输入的时候，则每次输出都换行。
另外，我还犯了其他一些低级错误，比如数据类型定义错误等等，这些错误自己调试的时候，不会出错，但是OJ上指定的某些测试用例肯定是没法通过的。所以要格外小心，OJ也不会告诉你哪个测试用例挂了，就很浪费时间，为了提高效率，写程序的时候就得多注意下，看清题目。</p>
]]></content>
  </entry>
  
</feed>
