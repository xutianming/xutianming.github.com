
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Xutianming Blog</title>
  <meta name="author" content="Xutianming">

  
  <meta name="description" content="写Python一段时间了，由于从初学到现在，一直还在熟悉语法和各种数据结构，以事先功能为主，自觉代码写的非常丑陋，现在也写了不少Python代码了，是时候挑战下习惯，遵循合适的代码风格，写简单易读的代码，Be Pythonic!! 本文主要参考了《Google Python Style Guide &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xutianming.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Xutianming Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Xutianming Blog</a></h1>
  
    <h2>www.cnblogs.com/iteagle</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:xutianming.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/22/python-style-guide/">Python Style Guide</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-22T14:01:00+08:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2013</time>
        
         | <a href="/blog/2013/09/22/python-style-guide/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>写Python一段时间了，由于从初学到现在，一直还在熟悉语法和各种数据结构，以事先功能为主，自觉代码写的非常丑陋，现在也写了不少Python代码了，是时候挑战下习惯，遵循合适的代码风格，写简单易读的代码，Be Pythonic!!</p>

<p>本文主要参考了《<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style Guide</a>》、《<a href="http://programmers.stackexchange.com/questions/119913/how-can-i-learn-to-effectively-write-pythonic-code">How can I learn to effectively write Pythonic code</a>》、《<a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html">Code Like a Pythonista: Idiomatic Python</a>》三篇文章，摘取了其中我现在可能需要遵循的，因为有些做比较大的系统的项目才用到的，暂时就没写。我主要以写小算法和小工具为主。</p>

<p>一、编码风格：</p>

<p>1、不要使用分号，也不要利用分号把两个命令放在一行</p>

<p>2、每行代码不超过80（特殊情况下，尽量不要把链接分开两行放）</p>

<p>3、少用括号，条件语句和return语句不要用括号（特殊情况下，利用括号来进行断行可以）</p>

<p>4、缩进用四空格（一般在文本编辑器里设置tab转四空格）</p>

<p>5、空格使用。语法符号之后用空格，但是括号、花括号、方括号之后不要用。逗号冒号之后有个空格，但是之前不要有。赋值号前后有空格，但是在使用默认参数的时候，不要加。</p>

<p>6、一系列的赋值或者相同的操作。没必要用空格来使赋值号对齐。</p>

<p>7、字符串的使用。尽量使用string format和&#8217;%&lsquo;而不是&rsquo;+&lsquo;。在循环中构造字符串的时候，不要使用&rsquo;+&lsquo;和&rsquo;+=&lsquo;，而是把所有的字符串先存在一个list里，然后在循环结束之后，用join函数。（这一点需要格外注意，具体原因原文有）</p>

<p>8、多行string尽量不要用三个连续的引号，因为会破坏整体的缩进。使用join函数拼接。</p>

<p>9、file和socket使用完毕要显式关闭</p>

<p>10、临时的实现临时插入的代码，使用TODO注释</p>

<p>11、import的组织。每行一个，不要一次import多个。按照标准库、第三方库、程序特有的，这一顺序进行引用，统一级别按照字母顺序排序。</p>

<p>12、命名规范。module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name。大部分使用了小写和下划线。</p>

<p>13、所有的脚本都应该是可import的，并且脚本被import之后，不能对当前脚本的功能有所影响。所以，脚本都应该有主函数！</p>

<pre><code>def main():
    …
if __name__ == '__main__':
    main()
</code></pre>

<p>不然的话，主程序的逻辑，会在被import的时候被执行。</p>

<p>14、注释。使用正确的注释方法。见原文。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/22/preprocessing/">打表与预处理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-22T13:31:00+08:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2013</time>
        
         | <a href="/blog/2013/09/22/preprocessing/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在ACM编程中，俗称打表，学名预处理。是我最近学习到的一个编程技巧。思想很简单自然，就是当有多组测试数据，但是每组测试数据的计算过程都是一模一样的。这时候，为了提高效率，节省计算资源，就会使用打表。</p>

<p>举例说明，计算斐波那契数列，可能要求输出第30-100项。算法中，我们会自底向上计算，也就是从第1项一直计算到第n项。每计算一项，都是重复这个过程。假如不对算法进行优化的话，我们计算第30项，要从第1项计算过来，计算第100项的时候，还要再从第一项计算一遍，这种情况下，就浪费计算资源了！</p>

<p>对于这种问题的优化思路，就是事先计算好所有可能需要输出的项，比如题目限制n&lt;=10000，那就把前10000项的斐波那契数列都计算好，存在数组里，然后根据测试用例的要求，输出对应的项就好了。</p>

<p>这种计算一次使用多次的思想，与动态规划非常相似。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/14/chi-square-information-gain-and-mutual-information/">卡方校验、信息增益和互信息</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-14T20:51:00+08:00" pubdate data-updated="true">Sep 14<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/09/14/chi-square-information-gain-and-mutual-information/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从一开始做文本分类到现在做的项目，一直在不断的学习新的知识，练习已经掌握的工具，也越来越深刻的认识到，“你所掌握的机器学习方法，并不是死板的一成不变的算法，而是一个一个的小工具，是解决问题的思路”。</p>

<p>这篇博客将对比三个在我进行文本挖掘相关工作的时候经常用到的小工具，以及我对他们的认识，仅限个人的粗浅观点，也是我当前的认识，不见得正确。</p>

<p><a href="http://zh.wikipedia.org/wiki/%E7%9A%AE%E7%88%BE%E6%A3%AE%E5%8D%A1%E6%96%B9%E6%AA%A2%E5%AE%9A">卡方校验</a></p>

<p>首先理解卡方校验的概念，除了维基百科，我总会看<a href="http://www.blogjava.net/zhenandaci/archive/2008/08/31/225966.html">这篇博客</a>。简单来讲，卡方校验是用来判别两个事件是否相关的方法，因此在特征提取、关键词提取中都有很多的应用。基本思路是，首先假设A、B不相关，然后根据A和B的联合概率分布，计算卡方值，公式在定义中都有给出，卡方值越大，越倾向于推翻原假设，也就是A、B越相关。在计算卡方值的过程中，最关键的问题是找到联合概率分布。那么我们应该如何理解卡方值呢？卡方值的含义其实是这样的，我们首先假设A、B不相关，也就是AB相互独立，那么我们可以为联合概率分布中的AB同时成立的事件计算期望值，根据定义公式显示，卡方值是这个期望值和实际值之间的差的平方除以期望值的和（定义和方差很像！），衡量了这两个量拟合的程度。那么，卡方值越大，代表期望值和实际值之间的差越大，也就是我们计算期望值所依赖的假设，是不成立的！</p>

<p>当我们想用卡方检验的方法，去判断两个事件是否相关的时候，理解问题的过程，就是建立事件A、B联合概率分布的过程，找到这个概率分布，就可以计算卡方值。举例说明的话，在文本分类的特征提取这一步，事件A是特征词w是否存在在本篇文档中，事件B是本篇文档是否属于类c。首先假设“w不是类c的特征词”，那么词w在属于类c的所有文档中出现的概率，应当与w在全部文档中出现的概率相同，我们依据这一假设，可以算出w出现在c类的文档数的期望，用期望值和实际值的差的平方除以作为卡方值。</p>

<p><a href="http://zh.wikipedia.org/wiki/%E7%9B%B8%E5%AF%B9%E7%86%B5">信息增益</a></p>

<p>也经常作为特征提取的方法，也用来衡量两个事件的相关性，但是是从信息论的角度来的。信息论用熵来衡量信息量。信息增益，简单理解就是在已知条件B的情况下，事件A的信息量的改变程度，就是熵的改变程度。同样有<a href="http://www.blogjava.net/zhenandaci/archive/2009/03/24/261701.html">一篇博客</a>讲得很透彻。从上面的描述可以看出，计算信息增益的关键是计算熵和条件熵。所以说，信息增益对应的概率分布，是普通的概率分布和一个条件概率分布。那么我们应该如何具体理解信息增益呢？我们首先计算事件A的信息熵，然后考虑事件B，计算在有事件B的情况下的条件熵，两者之差，就是信息熵的改变，改变越大，说明事件B对于事件A的相关性越大。由于涉及到信息论，所以信息量改变这一点，就变的略显抽象。</p>

<p>仿照上文中对卡方校验的介绍。利用信息增益解决问题的关键，在于找到这个条件概率分布，以计算条件熵。同样举文本分类中特征提取这个例子。事件A是指文档属于类ci，事件B是词w是否出现在文档中。根据P(Ci|w)和P(Ci|^w)这两个条件概率分布，可以计算条件熵H(C|T)。</p>

<p>不过仔细读过信息增益的概念，发现我们上面介绍的和KL散度差别挺大的，目前我也不能理解这两种概念是否本质上相同，但是在分类和挖掘领域，大家一般是像我说的那样去理解信息增益的。</p>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E4%BF%A1%E6%81%AF">互信息</a></p>

<p>在互信息定义的多条公式中，我一般使用第三个，就是X，Y熵之和减去联合熵。根据联合熵，就可以发现，决定互信息的，也是一个联合概率分布。</p>

<p>比较形象的理解互信息的公式方法是，认为事件X和事件Y相关，可以让总信息熵减少多少，差别越大，X和Y越相关。计算互信息的关键，是计算联合熵，因此在用互信息解决问题的适合，找到这个联合概率分布，是核心。不要试图去寻找其他的概率分布，实践表明，互信息的联合概率分布与卡方检验的非常相似，都是x是否怎样，y是否怎样。同样以文本分类为例，X为文档是否属于类c，Y事件为文档是否包含w，然后利用这个概率分布去计算联合熵。这么一看，和卡方检验几乎完全相同！只是利用了不同的理论基础。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/02/dynamic-programming/">动态规划</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-02T19:53:00+08:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2013</time>
        
         | <a href="/blog/2013/09/02/dynamic-programming/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当遇到复杂问题的时候，我们很自然的想要降低问题的复杂度和规模。在《算法导论》中，作者将动态规划和分治算法都当做降低问题规模，将复杂问题转化为子问题的方法。不同的是，分治算法划分出的子问题都是独立的，而动态规划中的子问题相互之间是非独立的，高层的子问题（离原问题比较近）往往依赖于低层子问题。所以假如不利用动态规划，自底向上计算这类问题的时候，会有大量重复的计算，从而使算法的效率低。</p>

<p>那么，动态规划的本质就是建立一个表，存储子问题的结果，在计算高层问题的时候，直接利用表中的结果。这就是动态规划的基本思想。动态规划往往被用来计算最优化问题，利用的理论是子问题最优化理论，也就是一个最优化解的路径上的所有子问题，也都是当前最优化的。但是，这已经不是动态规划的核心了，我之前就在理解动态规划的时候，犯了这个错误。在试图利用动态规划去解决问题的时候，我往往纠结于去寻找这样的最优化子结构。其实有时候，这种最优化子结构并不好找甚至没有，但是也可以利用动态规划去解。动态规划的基本思想，还是很朴素的。</p>

<p>最近在TopCoder上读了一个黄名大牛写的<a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static">动态规划进阶手册</a>深受启发。文中指出，动态规划应该这么描述：动态规划算法往往建立在一个递归方程和这个方程的初始状态之上（很像那种找递推公式的问题）。每个子问题，都建立在之前发现并计算好的问题上。动态规划问题往往都有多项式级别的复杂度，因此比暴力搜索和回溯算法效率要高（这一点我还不是特别明白，文中有提出，多项式复杂度的问题都可以用动态规划来解决）。</p>

<p>动态规划问题的解决过程是分为两步：定义问题的状态（或者说是子问题），发现如何又一个状态转移到下一个状态（也就是定义状态转移方程，是上文指出的“递归方程”），更准确的说，如何利用已有的子状态，计算下一个状态，因为有时候不是从i转移到i+1。</p>

<p>举例说明：</p>

<p>给定N个硬币，价值分别为（v1，v2，v3&hellip;vN），给定价值和S。求解价值和为S的硬币集合，使其包含的硬币个数最少，每种价值的硬币可以使用任意多个。</p>

<p>问题分析：</p>

<p>在这个问题中我们要求解的结果是价值和S，那么定义“状态”为当前价值和为i（i&lt;S），对于所有的状态j（j>i），要利用i来求解，而对于状态j(j&lt;i)，要在计算状态i之前计算好。在实践中，我发现子状态往往是针对要求解的那个问题的。</p>

<p>对于状态i，我们假设，所有的子状态j（j&lt;i）都已经计算出结果来了。那么i如何利用子结果来计算。对于所有价值小于i 的硬币（循环遍历）j，使用此硬币，使价值和变为i-j，由于i-j&lt;i，那么此子问题，我们应该已经计算好了，假设硬币数为m，则i状态的结果应为m+1。遍历过程中，我们把最小的那个结果存给状态i。</p>

<p>基于这种想法，我们需要从状态0开始，到状态s逐一计算。也就是动态规划中所谓的，从顶向下思考，从底向上计算。这里有个思考陷阱，千万不要想如何从i计算i+1，而是如何利用已有的所有子状态j(j&lt;=i)计算i+1。就写这篇博客的过程，我因为想当然认为这样，差点进入死胡同。</p>

<p>这是动态规划最基本的思考过程。</p>

<p>一般情况下，我们要遍历所有的比i低的状态j，但是并不是所有的j都能转换到i。在这个硬币问题中取决于，是否有个硬币k，使得S[j]+vk=S[i]。这就是状态转移的条件，所以在实践中，我们一般要判断状态j能否转移到条件i，在上例中没有判断的原因是，我们根据硬币价值遍历，遍历到的都肯定满足转移的条件。其他问题，比如无向图中，状态节点j能否转移到节点i取决于i和j之间是否有一条边。这就要判断了，当然假如存储图结构的时候，存储了所有指向节点i的入节点j，就可以遍历这个节点集了，但是对于自底向上的动态规划解决方案中，很少出现。</p>

<p>更复杂一点，状态转移不是一维的，变成二维甚至多维（目前只见过二维）。这种问题，通过比较好的定义子状态，也很好理解。</p>

<p>还有其他的情况下，限制条件所需的信息和我们所求的结果并不一致。比如赋权图中，从节点j到节点i的最短路径，在权值和小于s的前提下。我们最终关心的是路径长度，但是状态转移的限制条件是权值和，这时候需要一个二维数组来存储。</p>

<p>更复杂的情况，乍一看并不是动态规划问题，但是和我们以前遇到过的动态规划问题很像，这时候，我们需要一些转变，把问题转换成以前的问题的升级版去求解。这是最难的，菜鸟级别的我暂时还没什么感受。留在日后补充吧。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/26/tooltips-on-mouse-hover-using-d3/">为控件增加鼠标悬浮提示</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-26T14:21:00+08:00" pubdate data-updated="true">Aug 26<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/26/tooltips-on-mouse-hover-using-d3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上星期阅读了《Interactive Data Visualization for the Web》一书之后，便开始尝试使用D3js了。以前一直没怎么写过前端和界面，个人对于坐标位置布局什么的相当没感觉，总是乱乱的。所以这次写来，大部分也都是用的别人写好的现成的东西，在这个基础上做些改动。</p>

<p>今天做的改动之一就是为标签Text增加鼠标悬浮事件，提示改概念的定义。</p>

<p>效果图如下：</p>

<p><img src="http://i.imgur.com/0E53nrC.jpg" alt="Imgur" /></p>

<p>这段代码参考了StackOverflow上的这个<a href="http://stackoverflow.com/questions/10805184/d3-show-data-on-mouseover-of-circle">帖子</a></p>

<pre><code>// Show defination of the current item
function show_defination(d) {
    d3.select(this)
        .append("svg:title")
        .text(function(d) {return d.def;})
        .attr("x",function(d) {return d.x+10;})
        .attr("y",function(d) {return d.y+10;})
}
</code></pre>

<p>我添加的代码如上，绑定在text控件的mouseover时间上。<code>on("mouseover",show_defination);</code></p>

<p>另外我还发现了一个很好的在线校验json的<a href="http://jsonlint.com/">网站</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/recursion-problem-and-hmm-model/">ACM中递归问题解决方法思考</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-20T21:47:00+08:00" pubdate data-updated="true">Aug 20<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/20/recursion-problem-and-hmm-model/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在做ACM的练习题来练习编程的基本功，今天研究到了递归问题。就是通过寻找递推公式，来解决问题。</p>

<p>在总结方法的过程中，发现，对于一些比较简单的题目，可以在纸上比较轻易的模拟过程的问题，可以通过观察第n项与前面的1-3项之间的关系，直接得到递推公式。</p>

<p>比如：</p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1001&amp;ojid=0&amp;cid=1531&amp;hide=0">超级楼梯</a></p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1002&amp;ojid=0&amp;cid=1531&amp;hide=0">一只小蜜蜂&hellip;</a></p>

<p>这些问题都比较简单直观，所以很容易思考直接获得递推公式。</p>

<p>而其他的一些问题，可能就相对来说抽象一些，需要我们画图，找一下规律，这时候千万不要怕麻烦，画图可以很直观的帮助我们找到规律，也就是递推公式。</p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1004&amp;ojid=0&amp;cid=1531&amp;hide=0">骨牌铺方格</a></p>

<p><a href="http://acm.hdu.edu.cn/webcontest/contest_showproblem.php?pid=1009&amp;ojid=0&amp;cid=1531&amp;hide=0">Tiling_easy version</a></p>

<p>比如上面这种铺砖的，画图之后，有目的的去观察，有n-1和n-2项如何去铺砖得第n项，就可以发现递推公式。这种一般从第三项之后，才会有规律。也就是找第四项和第三、第二项之间的关系。</p>

<p>总而言之，这类问题考验思维能力要强于对编程能力的考验。思考的方法更为重要。我大体总结了一下，这类问题主要有两种思考的方式，一种是从前往后，一种是从后往前。</p>

<p>从前往后，就是考察第一、第二项，这一般是递推公式的初始项，然后考察第三项、第四项、第五项，在计算这几项的时候，看能否提出一种可以推广的计算方法，这种方法，抽象来，就是递推公式。这种方法的优点是，比较直观，可以画图，容易理解，缺点是，有些问题没法解决。</p>

<p>从后往前，就是直接考察第n项的得出，有几种可能来构造第n项，每种可能如何用第n-1项、第n-2项的值，来构造。这种方法的优点是通用性更高一些，只要脑筋转的过来，大部分问题都可以通过这种方法找出递推公式。缺点就是比较抽象，不怎么好想。</p>

<p>写到这里，我觉得这种问题的解决，好像是HMM中的前向算法和后向算法，分别就是从前向后和从后向前，进行状态的转移。不过再仔细思考，这也只是形似而已，似乎在本质上，双方没有数学层面上的必然联系。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/19/my-general-view-on-data-visualization/">对数据可视化的初步认识</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-19T14:06:00+08:00" pubdate data-updated="true">Aug 19<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/19/my-general-view-on-data-visualization/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>先说点废话，导师是研究数据可视化方向的，所以平时在实验室的工作大部分是和数据可视化相关联的。每天至少也会花六七个小时在相关的方面。大四一年七七八八做了很多项目，很少有和数据可视化相关的，个人感觉也都没啥技术含量，觉得大四一年基本上白忙活了，自己也没提高多少。研一的时候开始接触了数据挖掘和机器学习，也去公司实习，学习了很多这方面的知识，对这个方向也有了大致的了解，非常喜欢，很有些相见恨晚的感觉。为什么呢？主要是惊诧于数据的强大力量。说到数据的价值，其实一堆一堆的数字、文字等等，是没什么价值的，价值在于数据中蕴含的信息。</p>

<p>机器学习和数据挖掘，就是这样的工具，可以把信息，从浩瀚的数据海洋中提取出来。海量数据的信息处理，就是最近很火的“大数据”了。在未来，互联网向各个传统行业，我们生活的方方面面不断渗透的过程中，数据挖掘和机器学习的方法，是可以做很多很多的事情的。</p>

<p>再说数据可视化，以前的时候理解一直很不到位，一直觉得数据可视化，就是用一种很好的方式，来展现信息，表达观点，这样可以提高沟通的效率，也很符合人的认知习惯。那么数据可视化，应该技术含量很低，更多的是个经验学科，自己领域里的数据，一般用什么样的形态来表示，这个从业时间长了，自己就了解了。这两天在看《Interative Data Visualization for the Web》这本书（中文好像叫《D3js实战》么？），只看了一点，就有很大收获。但从对数据可视化的由来和认识来讲，感觉作者理解的好深刻。数据可视化分为解释性的可视化（explainatory）和探索性的可视化（exploratory）。前者就是我一直认为的那样，而后者我导师一般说是“可视分析”，通过提供对数据的交互手段，帮助人们挖掘知识、信息。</p>

<p>那么数据可视化和数据挖掘机器学习应当是有着非常密切的关系的。先说解释性的可视化。一般来讲，我们说数据挖掘机器学习是非常强大的工具，可以帮助我们从数据中学习，以进行分类、回归、聚类等工作，解决实际问题。那么挖掘出来的信息，需要交流和传递，才能有产生价值，这时候，数据可视化可以帮助你，更好地把你想表达的信息传递出去。那么可视分析呢，意义在于，有些问题，数据挖掘可能帮不上忙，但是人们的长期工作以来，经验积累，有很多先验知识，这些知识一般比较难在数据挖掘的过程中有所帮助。那么可视分析就可以帮助这些有经验的人士，更好的操作数据，可以快速的产生数据的不同视图，让其他行业的专家也可以享受到挖掘的福利。这方面，美国已经有企业做的很成熟了，公司也都上市了，Tableau。回头我也要试用学习一下。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/07/c-plus-plus-input-and-output/">C++输入输出总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-07T09:23:00+08:00" pubdate data-updated="true">Aug 7<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/07/c-plus-plus-input-and-output/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>输入：
1 . 未说明有多少个input block</p>

<pre><code>while(scanf("%d %d",&amp;a,&amp;b)!=EOF) 
{    ...    }
</code></pre>

<p>scanf返回的是输入的变量的个数，EOF=-1表示没有输入</p>

<pre><code>while(cin&gt;&gt;a&gt;&gt;b) {    ...    }2 . 说明有N个input block    

scanf("%d",&amp;n) ;    for( i=0 ; i&lt;n ; i++ )     {...} 
    cin &gt;&gt; n;   for( i=0 ; i&lt;n ; i++ )     { .... } 3 . 输入是一整行的字符串
C  
char buf[20];     gets(buf); 

// 如果用string buf;来保存：
getline( cin , buf );     // 如果用char buf[ 255 ]; 来保存：     cin.getline( buf, 255 );
</code></pre>

<p><code>scanf(“ %s%s”,str1,str2)</code>，在多个字符串之间用一个或多个空格分隔；若使用gets函数，应为gets(str1); gets(str2); 字符串之间用回车符作分隔。通常情况下，接受短字符用scanf函数，接受长字符用gets函数。而getchar函数每次只接受一个字符，经常c=getchar()这样来使用。getline 是一个函数，它可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下：    <code>istream&amp; getline(char line[], int size, char endchar = '\n');</code>不用管它的返回类型，来关心它的三个参数：
* char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。<em> int size : 最多接受几个字符？用户超过size的输入都将不被接受。</em> char endchar :当用户输入endchar指定的字符时，自动结束。默认是回车符。例如：char name[4];cin.getline(name,4,&lsquo;\n&rsquo;);由于 endchar 默认已经是 &lsquo;\n&#8217;，所以后面那行也可以写成：cin.getline(name,4);输出：
1 . 输出之后换行    C:    {     &hellip;.     printf(&ldquo;%d\n&rdquo;,ans);     }     C++:    {     &hellip;     cout &lt;&lt; ans &lt;&lt; endl;     }
2 . 每个输出之间有空行</p>

<pre><code>  while(scanf("%d %d",&amp;a, &amp;b) != EOF)           printf("%d\n\n",a+b);    
C++:    cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p>3 . 输出结束之后输出空行</p>

<pre><code>C:    for (k=0;k&lt;count;k++) {     while (…) {              printf(" %d\n",result);       
  }       
  if (k!=count-1) printf("\n");     
}     C++   // 类似，输出语句换一下即可。
</code></pre>

<p>在学习了以上基础之后，我在HDUOJ上做了十几个题目来练习，也犯了不少错误，总结如下，以避免以后再犯，提高编程的成功率和效率：
* 未说明有多少个输入块时，scanf要和EOF比较，这个和cin的使用不同，不然的话OJ上会超时
* 同样的道理，也不要用<code>while(true)</code>来代替<code>while(cin&gt;&gt;a)</code>，也会在输入结束的时候，仍然执行从而超时
* 再就是输出有换行，要输出两个<code>endl</code>的时候，要注意假如指定输入个数，最后一次输出之后，不要再换行的。没指定有多少个输入的时候，则每次输出都换行。
另外，我还犯了其他一些低级错误，比如数据类型定义错误等等，这些错误自己调试的时候，不会出错，但是OJ上指定的某些测试用例肯定是没法通过的。所以要格外小心，OJ也不会告诉你哪个测试用例挂了，就很浪费时间，为了提高效率，写程序的时候就得多注意下，看清题目。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/24/bye-my-childhood/">姥爷的老房子，我的童年</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-24T12:59:00+08:00" pubdate data-updated="true">Jul 24<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/24/bye-my-childhood/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前几天，姥爷去世了。最疼爱我的姥爷，离开了。这几天一直在忙着各种后事，今天终于得以清闲，和爸爸妈妈一起给姥爷打扫房间，处理一些剩余的食物，几年来，也是第一次再好好看看这栋房子，也许，以后再也没机会了吧。</p>

<p>现在居住的大院里，几乎有我童年的所有回忆，从幼儿园起，我就在这所大院里玩，幼儿园-学前班-小学，直到小学五年级，我们家也搬了进来，住在姥爷家对面的楼上，于是，我的初中-高中也在这里度过。直到我考上大学，18岁，离开了泰安，去往武汉，再来到北京。一晃已经5年过去了，我也已经23岁了。</p>

<p>我生命的前十八年，几乎都是在这座大院里度过，几乎都和姥爷家密不可分，那时候，我几乎每天每星期，都会过来。都会亲亲姥爷的脸，都会吃姥爷给我买的零食。但是，随着姥爷的离开，也许过不了多久，我就要和这栋老房子说再见了。</p>

<p>我想在我的博客里，留下这些记忆。</p>

<p><img src="http://i.imgur.com/sm0cACZ.jpg" alt="Imgur" /></p>

<p>那时候，每天放学，我都会飞奔到姥爷家，看会报纸，吃会零食，放自行车，或者取家里的钥匙然后回家。姥爷经常会在我放学的点，站在门口的石榴树下等我回来，帮我停自行车，好让我赶紧回家休息。</p>

<p><img src="http://i.imgur.com/bquu6Dd.jpg" alt="Imgur" /></p>

<p>姥爷家的碳池子，秋天囤积碳，以供冬天取暖，不过已经废弃太久了，我记事起，这个就没用过，但是这成了我的游乐场所，我经常爬上爬下，从下面的小门里钻进钻出。</p>

<p><img src="http://i.imgur.com/DSjVd2p.jpg" alt="Imgur" /></p>

<p>姥爷门前的石榴树，也是我的乐园。由于疏于打理，每年夏天石榴树都会结很多的果子，但是秋天不到，大部分果子就都掉了。到了果实成熟的时候，往往只有几颗果子，这时候姥爷会分给我们几个小孩一人一个，超级甜。</p>

<p><img src="http://i.imgur.com/6hCeTbQ.jpg" alt="Imgur" /></p>

<p>正是7月底，就有些石榴炸开花了。大部分石榴都留不到秋天。</p>

<p><img src="http://i.imgur.com/LcbfokW.jpg" alt="Imgur" /></p>

<p>石榴树是很多蚂蚁的家。有时候我是这些蚂蚁的朋友，但大部分时间，我是他们的灾难。我会用开水烫，用脚踩，用针扎；偶尔无聊的时候，我会在小院里用蝇拍打苍蝇，喂他们，而且一般都不把苍蝇完全打死，看着苍蝇被蚂蚁撕咬。</p>

<p><img src="http://i.imgur.com/W74Vt1p.jpg" alt="Imgur" /></p>

<p>这是姥爷请人搭建的小储藏室，是他的百宝箱。他会把各种暂时用不到的东西都放进去，里面堆满了东西，但是都整齐的码在四周的墙上，屋子的中间还是留了很大的空地。姥爷是个仔细的人，什么都一丝不苟，力图做到干净整洁。墙上，还留有张贴姥爷讣告的痕迹。</p>

<p><img src="http://i.imgur.com/zIsTacF.jpg" alt="Imgur" /></p>

<p>进门是个小走廊，墙上的油迹还在，姥姥在世的时候，经常会在这里生火做饭，用小小的蜂窝煤炉子，想来现在应该再没人烧蜂窝煤了吧。那已经是十几年前的事情了。</p>

<p><img src="http://i.imgur.com/KuSvvfp.jpg" alt="Imgur" /></p>

<p>我长个子的时候，姥爷仔细的在墙上记录着我身高的变化，那是我小学的时候，等高中了，我已经比姥爷还高了。亲姥爷的时候，都需要弯下腰，姥爷要拍我的后脑勺，也得拉着我的脖子才可以。</p>

<p><img src="http://i.imgur.com/VQA7ptN.jpg" alt="Imgur" /></p>

<p>姥爷家的小院子，我的乐园。屋子窗下，姥爷搭的小台子，摆放一些杂物和花盆，台子下面，则是我的藏宝库，我把各种脏兮兮的玩意，藏在这下面，第二天继续玩。我在这里冻过冰，养过蝌蚪。</p>

<p><img src="http://i.imgur.com/xuEi1WQ.jpg" alt="Imgur" /></p>

<p>小院里的水龙头，姥姥会在这里洗菜洗衣服，这样不会弄脏屋子。而这里，是我的弹药补给地，那时候喜欢玩水，水枪、喷壶等等，石榴树上的蚂蚁，自然成了我的攻击对象。</p>

<p><img src="http://i.imgur.com/XUVWbUS.jpg" alt="Imgur" /></p>

<p>小院里的排水沟，姥爷自己通的，我经常在这里撒尿，一直到年纪很大了还这样，在墙上画地图，每次姥爷都会笑着骂我，但是从来没制止过我。</p>

<p><img src="http://i.imgur.com/gJSWPF4.jpg" alt="Imgur" /></p>

<p>进了屋子，是姥爷平时坐着喝茶的地方，最早的时候，姥爷和姥姥会在这里说话，后来只剩下了姥爷，再后来，姥爷也离开了。妈妈说我刚生下来，可以横着躺在沙发上，头脚都不会够到扶手。</p>

<p><img src="http://i.imgur.com/RxQrOYO.jpg" alt="Imgur" /></p>

<p>沙发旁的壁橱，姥爷放各种点心饮料的地方，每次来，我都会钻进壁橱，找我喜欢吃的东西。</p>

<p><img src="http://i.imgur.com/yL04Xdk.jpg" alt="Imgur" /></p>

<p>黑色的老鹰，一直都在，展翅雄飞。姥爷一直爱用的纸日历，已经好久没人撕了。小时候，每天早上我就会着急的撕下当天的日历，可是现在才明白，被撕去的日历，就是过去的时间，再也回不来了。</p>

<p><img src="http://i.imgur.com/VVZ2qox.jpg" alt="Imgur" /></p>

<p>姥爷的卧室，一如既往的整洁。姥爷每天下午的时光都是在这里度过的，睡了午觉，然后坐在写字台前练字，计划最近要做的事情，读报纸杂志。小时候，我趴在床上看《新白娘子传奇》的样子还历历在目，只是那时候的电视好小，也只有几个电视台。</p>

<p><img src="http://i.imgur.com/sOLBZFz.jpg" alt="Imgur" /></p>

<p>写字台的玻璃下面，会压着姥爷要记的事情，一些生活常识以及保健知识。还有所有孩子的电话。里面没有我的电话，因为一般都是我给姥爷打电话，而且我在外上学，号码常换。</p>

<p>物是人非，姥爷离开我们了，再也没人给我压岁钱，亲切的问我钱够不够花，学习情况怎么样，叮嘱我好好学习了。很快，爸爸妈妈也会搬离这个大院，住到新房子里，这里的样子，会越来越模糊吧。可是，这几乎我对泰安这个小城所有记忆的缩影，我18年最主要的记忆，都是和这里相关的。人总会长大，我也已经离开泰安5年了，还不知道以后会生活在哪个城市，但是应该很难再回来吧。</p>

<p><img src="http://i.imgur.com/8xQVz35.jpg" alt="Imgur" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/20/understanding-kernel-function/">核函数理解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-20T11:13:00+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/20/understanding-kernel-function/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>SVM相关的理论知识看过几遍，但是感觉一直都不是理解的很透彻，特别是核函数的概念。今天又查阅了大家写的学习笔记等资料，结合自己的实践经验，感觉对核函数的理解更进一步了，所以记录在这里。</p>

<p>一句话说明核函数的意义和作用：为使非线性可分问题转化为线性可分，将特征向量映射到高维，映射函数所满足的性质。</p>

<p>具体说来，svm可以直接解决线性可分的分类问题，对于近似线性可分的问题，通过增加松弛变量，也可以实现分类。那么对于非线性可分的问题呢，比较直观的想法是映射，也就是通过把特征映射到高维，使非线性可分问题转化为线性可分的问题。但是就一般的实际问题来讲，寻找这个映射很困难，而且很难有可推广的方法。于是提出了kernel trick。可以绕过寻找这个映射函数。</p>

<p>在理论公式的推导中，可以算出参数w的表示方法：</p>

<p><img src="http://i.imgur.com/KqPVcLl.png?1" alt="Imgur" /></p>

<p>于是分类超平面的函数也可以写成：</p>

<p><img src="http://i.imgur.com/UVGLjMS.png?3" alt="Imgur" /></p>

<p>这个公式中只有&lt;x(i),x>的内积形式，也就是说，我们映射之后，需要计算&lt;Fi(xi),Fi(x)>的内积。而我们定义的核函数，就是这一内积的形式。</p>

<p><img src="http://i.imgur.com/lLicBOp.png?1" alt="Imgur" /></p>

<p>如此一来，我们就可以用核函数直接替换内积，相当于，我们把原始的特征向量，映射到了高维，并且避免了寻找映射函数。而libsvm中推荐使用的RBF核函数，就是一个有着良好特性的核函数。可以将样本映射到一个更高维的空间，可以处理非线性的分类问题。而其关键的参数c和g分别为惩罚因子和核函数的参数。（RBF 核K(x, y) = exp(－γ || x －y ||的平方),γ > 0，g为gamma，就是r）。我们在使用libsvm训练之前，应该首先寻找最优的参数c和γ。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/codesegment/'>CodeSegment (1)</a></li><li><a href='/blog/categories/shu-ju-ke-shi-hua/'>数据可视化 (2)</a></li><li><a href='/blog/categories/wen-ben-wa-jue/'>文本挖掘 (2)</a></li><li><a href='/blog/categories/ji-qi-xue-xi/'>机器学习 (3)</a></li><li><a href='/blog/categories/za-xiang/'>杂项 (2)</a></li><li><a href='/blog/categories/sheng-huo/'>生活 (1)</a></li><li><a href='/blog/categories/suan-fa-ji-chu/'>算法基础 (4)</a></li><li><a href='/blog/categories/bian-cheng-yu-yan/'>编程语言 (1)</a></li></ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/22/python-style-guide/">Python Style Guide</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/22/preprocessing/">打表与预处理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/14/chi-square-information-gain-and-mutual-information/">卡方校验、信息增益和互信息</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/02/dynamic-programming/">动态规划</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/26/tooltips-on-mouse-hover-using-d3/">为控件增加鼠标悬浮提示</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/xutianming">@xutianming</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'xutianming',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/codesegment' style='font-size: 115.0%'>CodeSegment(1)</a> <a href='/blog/categories/数据可视化' style='font-size: 130.0%'>数据可视化(2)</a> <a href='/blog/categories/文本挖掘' style='font-size: 130.0%'>文本挖掘(2)</a> <a href='/blog/categories/机器学习' style='font-size: 145.0%'>机器学习(3)</a> <a href='/blog/categories/杂项' style='font-size: 130.0%'>杂项(2)</a> <a href='/blog/categories/生活' style='font-size: 115.0%'>生活(1)</a> <a href='/blog/categories/算法基础' style='font-size: 160.0%'>算法基础(4)</a> <a href='/blog/categories/编程语言' style='font-size: 115.0%'>编程语言(1)</a> </span>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Xutianming -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'xutianming';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
